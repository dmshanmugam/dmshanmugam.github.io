---
layout: post
title: Never transcribe numbers again
---

I've come up with two workflows for avoiding number transcription when writing research papers. They both require programmatically defining and exporting statistics you plan to report. For LaTex, the process is simple: you can print out a list of macro commands (of the form \macro{item_name}{value}), and refresh this list of commands every time you'd like to refresh your results. If you write LaTex locally, you can write the macros out to a file that you import into your paper.

For Google Docs, the procedure is a bit more involved: 

1. **Make an internal and external Google doc and a results Google Sheet**. The internal document is for edits, internal comments, and variable names; the external document is automatically populated with data.  The Google Sheet will store all data in key-value format.
2. **Export data you intend to report to a CSV file**. The first column should be the item name and the second column should be the value.
3. **Import CSV into your Google Sheet.** Ensure that the name of the sheet is 'output_results'; this is what the script below will look for.
4. **Modify the script below to include IDs of each file**. Each of the three file IDs can be found at the end of its URL; make sure to remove trailing modifiers. 
5. **Upload the script to as an App Script**. here: https://script.google.com/home/projects/. 
6. **Run the Google App script**. The script will prompt you for permissions when it is first run. Your external document will be written over with the internal document, where places where you write {{KEY_A}} will be filled in with VALUE_A. Comments on the internal document will also transfer to the external document, but this function is easily removed.
7. **Invite collaborators to comment on the external document**. I find it easiest to restrict access to the internal doc to a smaller set of collaborators, who can then carefully propagate the feedback back into the internal state.

The code was produced in close collaboration with ChatGPT, making this a *doubly* generative procedure. The two document set-up is admittedly clunky -- I landed here because a single document doesn't allow for paper regeneration (since you'd overwrite your variable names). Email me if you have better ideas, or other ways you embed reproducibility into your research :) 

```
/**
 * Required Scopes:
 *   https://www.googleapis.com/auth/documents
 *   https://www.googleapis.com/auth/drive
 *   https://www.googleapis.com/auth/drive.file
 *   https://www.googleapis.com/auth/spreadsheets
 */

/** ===== CONFIG ===== */
const TEMPLATE_DOC_ID = '1pC62p6l9xMHgcjRSPy5ZW1XiXGLGKLpy6Xb_BXLzlJA'; // contains {{TOKENS}}
const OUTPUT_DOC_ID   = '1TmAPQgP6O0XL7hpoar5B2oelMvWe_D6EyTNQW6BRaTI'; // stable destination
const SPREADSHEET_ID  = '19ZgSb2N4fA0m5Ukf8NL0ijoF6KHxQoIG2b2oUmaWzcE'; // A=key, B=value
const SHEET_NAME      = 'output_results';
const TZ              = Session.getScriptTimeZone();

// Controls which comments to copy
const COPY_RESOLVED_COMMENTS = false; // set true if you want resolved comments too

function refreshOutputDocFromTemplate_keyValue() {
  // 1) Read key–value pairs from A:B
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = ss.getSheetByName(SHEET_NAME);
  if (!sh) throw new Error(`Sheet not found: "${SHEET_NAME}".`);
  const lastRow = sh.getLastRow();
  const rows = sh.getRange(1, 1, lastRow, 2).getValues(); // A:B
  const replacements = {};
  rows.forEach(([rawKey, rawVal]) => {
    const key = (rawKey || '').toString().trim();
    if (!key) return;
    replacements[`{{${key}}}`] = formatByName_(rawVal, key, TZ);
  });

  // 2) Open docs
  const templateDoc = DocumentApp.openById(TEMPLATE_DOC_ID);
  const outputDoc   = DocumentApp.openById(OUTPUT_DOC_ID);

  // 3) Clone template → output (identical content/structure before comments or replacements)
  cloneDocContent_(templateDoc, outputDoc);
  outputDoc.saveAndClose(); // ensure Kix model is up to date before anchoring comments

  // 4) Get template comments (including anchors) and recreate them in the output *before* text replacement
  const templateComments = getCommentsWithContext_(TEMPLATE_DOC_ID, { includeResolved: COPY_RESOLVED_COMMENTS });
  recreateCommentsByAnchor_(OUTPUT_DOC_ID, templateComments);

  // 5) Re-open output and do token replacements (comments remain anchored)
  const outDoc = DocumentApp.openById(OUTPUT_DOC_ID);
  const targets = [outDoc.getBody(), outDoc.getHeader(), outDoc.getFooter()].filter(Boolean);
  targets.forEach(sec => {
    for (const [ph, val] of Object.entries(replacements)) {
      sec.replaceText(escapeForRegex_(ph), String(val));
    }
  });
  outDoc.saveAndClose();

  Logger.log('✅ Refreshed output (with comments): https://docs.google.com/document/d/' + OUTPUT_DOC_ID + '/edit');
}

/* ---------------- Comment handling ---------------- */

/**
 * Fetch open (and optionally resolved) comments from a doc, with their Drive 'anchor' field.
 * Using the anchor lets us recreate the comment at the exact range in an identical clone.
 */
function getCommentsWithContext_(docId, opts) {
  const includeResolved = opts && opts.includeResolved;
  const url = `https://www.googleapis.com/drive/v3/files/${docId}/comments` +
              `?fields=comments(id,content,resolved,deleted,anchor,quotedFileContent,replies(id,content,deleted))`;
  try {
    const resp = UrlFetchApp.fetch(url, {
      headers: { 'Authorization': 'Bearer ' + ScriptApp.getOAuthToken() }
    });
    const data = JSON.parse(resp.getContentText());
    const all = (data.comments || []);
    const filtered = all.filter(c =>
      !c.deleted &&
      (includeResolved ? true : !c.resolved)
    );
    Logger.log(`Found ${filtered.length} comment(s) to copy (includeResolved=${includeResolved}).`);

    return filtered.map(c => ({
      content: c.content || '',
      anchor: c.anchor || null,
      contextText: (c.quotedFileContent && c.quotedFileContent.value) ? c.quotedFileContent.value : '',
      replies: (c.replies || []).filter(r => !r.deleted).map(r => ({ content: r.content || '' }))
    }));
  } catch (e) {
    Logger.log('Error fetching comments: ' + e);
    return [];
  }
}

/**
 * Create comments in the destination using the original Drive anchor.
 * Assumes the destination doc content is identical to the source at time of anchoring.
 */
function recreateCommentsByAnchor_(docId, comments) {
  if (!comments || comments.length === 0) return;

  comments.forEach((c, idx) => {
    try {
      if (!c.anchor) {
        Logger.log(`⚠️  Comment ${idx + 1} has no anchor; skipping (content starts: "${c.content.substring(0, 40)}...")`);
        return;
      }
      const createUrl = `https://www.googleapis.com/drive/v3/files/${docId}/comments?fields=id`;
      const payload = {
        content: c.content || '',
        anchor: c.anchor // reuse exact anchor from template
      };
      const res = UrlFetchApp.fetch(createUrl, {
        method: 'post',
        headers: {
          'Authorization': 'Bearer ' + ScriptApp.getOAuthToken(),
          'Content-Type': 'application/json'
        },
        payload: JSON.stringify(payload),
        muteHttpExceptions: true
      });
      const code = res.getResponseCode();
      if (code !== 200 && code !== 201) {
        Logger.log(`⚠️  Failed to create comment (${code}): ${res.getContentText()}`);
        return;
      }
      const newComment = JSON.parse(res.getContentText());
      Logger.log(`✅ Recreated comment ${idx + 1} (id=${newComment.id})`);

      // Add replies
      (c.replies || []).forEach((r) => {
        try {
          const replyUrl = `https://www.googleapis.com/drive/v3/files/${docId}/comments/${newComment.id}/replies?fields=id`;
          const rr = UrlFetchApp.fetch(replyUrl, {
            method: 'post',
            headers: {
              'Authorization': 'Bearer ' + ScriptApp.getOAuthToken(),
              'Content-Type': 'application/json'
            },
            payload: JSON.stringify({ content: r.content || '' }),
            muteHttpExceptions: true
          });
          if (rr.getResponseCode() !== 200 && rr.getResponseCode() !== 201) {
            Logger.log(`Warning: could not add a reply: ${rr.getContentText()}`);
          }
        } catch (e) {
          Logger.log('Warning: reply add failed: ' + e);
        }
      });
    } catch (e) {
      Logger.log('Warning: recreate comment failed: ' + e);
    }
  });
}

/* ---------------- Formatting helpers ---------------- */
function formatByName_(v, name, tz) {
  if (v == null) return '';
  if (/DATE/i.test(name) && (v instanceof Date || !isNaN(Date.parse(v)))) {
    const d = v instanceof Date ? v : new Date(v);
    return Utilities.formatDate(d, tz, 'MMMM d, yyyy');
  }
  if (/(TOTAL|AMOUNT|REVEN|REVENUE|COST|PRICE|EXPENSE)/i.test(name) && !isNaN(+v)) {
    return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(+v);
  }
  if (/(^N$|^N_|_COUNT|COUNT$|^NUM|QUANTITY)/i.test(name) && !isNaN(+v)) {
    return new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(+v);
  }
  return String(v);
}

function escapeForRegex_(text) {
  return text.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

/* ---------------- Clone helpers (safe clear) ---------------- */
function cloneDocContent_(srcDoc, dstDoc) {
  const srcBody = srcDoc.getBody();
  const dstBody = dstDoc.getBody();
  emptyBody_(dstBody);
  copyBodyChildren_(srcBody, dstBody);

  const srcHeader = srcDoc.getHeader();
  if (srcHeader) {
    let dstHeader = dstDoc.getHeader();
    if (!dstHeader) dstHeader = dstDoc.addHeader();
    emptyContainer_(dstHeader);
    copyContainerChildren_(srcHeader, dstHeader);
  }

  const srcFooter = srcDoc.getFooter();
  if (srcFooter) {
    let dstFooter = dstDoc.getFooter();
    if (!dstFooter) dstFooter = dstDoc.addFooter();
    emptyContainer_(dstFooter);
    copyContainerChildren_(srcFooter, dstFooter);
  }
}

/** Safely empty the document body (from emptyDocument pattern) */
function emptyBody_(body) {
  body.appendParagraph(''); // ensure at least one CR/LF
  while (body.getNumChildren() > 1) {
    body.removeChild(body.getChild(0));
  } // leave one blank paragraph
  const last = body.getChild(0);
  if (last.getType() === DocumentApp.ElementType.PARAGRAPH) {
    last.asParagraph().setText(' ');
  }
}

/** Same approach for header/footer containers */
function emptyContainer_(container) {
  container.appendParagraph('');
  while (container.getNumChildren() > 1) {
    container.removeChild(container.getChild(0));
  }
  const last = container.getChild(0);
  if (last.getType() === DocumentApp.ElementType.PARAGRAPH) {
    last.asParagraph().setText(' ');
  }
}

/* ---- Copy helpers that preserve element types & formatting ---- */
function copyBodyChildren_(srcBody, dstBody) {
  for (let i = 0; i < srcBody.getNumChildren(); i++) {
    appendElementToBody_(dstBody, srcBody.getChild(i));
  }
}

function copyContainerChildren_(src, dst) {
  for (let i = 0; i < src.getNumChildren(); i++) {
    appendElementToContainer_(dst, src.getChild(i));
  }
}

function appendElementToBody_(dstBody, elem) {
  switch (elem.getType()) {
    case DocumentApp.ElementType.PARAGRAPH:
      dstBody.appendParagraph(elem.copy().asParagraph());
      break;
    case DocumentApp.ElementType.LIST_ITEM:
      dstBody.appendListItem(elem.copy().asListItem());
      break;
    case DocumentApp.ElementType.TABLE:
      dstBody.appendTable(elem.copy().asTable());
      break;
    case DocumentApp.ElementType.TABLE_OF_CONTENTS:
      dstBody.appendTableOfContents(elem.copy().asTableOfContents().getAttributes());
      break;
    case DocumentApp.ElementType.HORIZONTAL_RULE:
      dstBody.appendHorizontalRule();
      break;
    case DocumentApp.ElementType.PAGE_BREAK:
      dstBody.appendPageBreak();
      break;
    default:
      dstBody.appendParagraph(elem.getText ? elem.getText() : '');
  }
}

function appendElementToContainer_(dst, elem) {
  switch (elem.getType()) {
    case DocumentApp.ElementType.PARAGRAPH:
      dst.appendParagraph(elem.copy().asParagraph());
      break;
    case DocumentApp.ElementType.LIST_ITEM:
      dst.appendListItem(elem.copy().asListItem());
      break;
    case DocumentApp.ElementType.TABLE:
      dst.appendTable(elem.copy().asTable());
      break;
    case DocumentApp.ElementType.TABLE_OF_CONTENTS:
      dst.appendTableOfContents(elem.copy().asTableOfContents().getAttributes());
      break;
    case DocumentApp.ElementType.HORIZONTAL_RULE:
      dst.appendHorizontalRule();
      break;
    case DocumentApp.ElementType.PAGE_BREAK:
      dst.appendPageBreak();
      break;
    default:
      dst.appendParagraph(elem.getText ? elem.getText() : '');
  }
}
```